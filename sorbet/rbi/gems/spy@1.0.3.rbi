# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `spy` gem.
# Please instead update this file by running `bin/tapioca gem spy`.

module Spy
  class << self
    # retrieve the spy from an object
    #
    # @param base_object
    # @param method_names *[Symbol]
    # @return [Subroutine, Array<Subroutine>]
    #
    # source://spy//lib/spy.rb#156
    def get(base_object, *method_names); end

    # retrieve the constant spies from an object
    #
    # @param base_module
    # @param constant_names *[Symbol]
    # @return [Constant, Array<Constant>]
    #
    # source://spy//lib/spy.rb#168
    def get_const(base_module, *constant_names); end

    # Create a mock object from a given class
    #
    # @param klass [Class] class you wish to mock
    # @param stubs *[Symbol, Hash] methods you with to stub
    # @return [Object]
    #
    # source://spy//lib/spy.rb#122
    def mock(klass, *stubs); end

    # create a mock object from a given class with all the methods stubbed out
    # and returning nil unless specified otherwise.
    #
    # @param klass [Class] class you wish to mock
    # @param stubs *[Symbol, Hash] methods you with to stub
    # @return [Object]
    #
    # source://spy//lib/spy.rb#135
    def mock_all(klass, *stubs); end

    # removes the spy from the from the given object
    #
    # @param base_object
    # @param method_names *[Symbol]
    # @return [Subroutine, Array<Subroutine>]
    #
    # source://spy//lib/spy.rb#32
    def off(base_object, *method_names); end

    # removes stubs from given module
    #
    # @param base_module [Module]
    # @param constant_names *[Symbol]
    # @return [Constant, Array<Constant>]
    #
    # source://spy//lib/spy.rb#102
    def off_const(base_module, *constant_names); end

    # remove the stub from given Class
    #
    # @param base_class [Class]
    # @param method_names *[Symbol]
    # @return [Spy]
    #
    # source://spy//lib/spy.rb#60
    def off_instance_method(base_class, *method_names); end

    # create a spy on given object
    #
    # @param base_object
    # @param method_names *[Hash,Symbol] will spy on these methods and also set default return values
    # @return [Subroutine, Array<Subroutine>]
    #
    # source://spy//lib/spy.rb#20
    def on(base_object, *method_names); end

    # create a stub for constants on given module
    #
    # @param base_module [Module]
    # @param constant_names *[Symbol, Hash]
    # @return [Constant, Array<Constant>]
    #
    # source://spy//lib/spy.rb#77
    def on_const(base_module, *constant_names); end

    # stubs the instance method of a given Class so all instance methods of this
    # class will have the given method stubbed
    #
    # @param base_class [Class] The class you wish to stub the instance methods of
    # @param method_names *[Symbol, Hash]
    # @return [Spy, Array<Spy>]
    #
    # source://spy//lib/spy.rb#48
    def on_instance_method(base_class, *method_names); end

    # unhook all methods
    #
    # source://spy//lib/spy.rb#148
    def teardown; end

    private

    # source://spy//lib/spy.rb#183
    def create_and_hook_spy(base_object, method_name, singleton_method = T.unsafe(nil)); end
  end
end

module Spy::API
  # source://spy//lib/spy/api.rb#5
  def assert_received(base_object, method_name); end

  # source://spy//lib/spy/api.rb#10
  def assert_received_with(base_object, method_name, *args, &block); end

  # source://spy//lib/spy/api.rb#15
  def have_received(method_name); end
end

class Spy::API::DidNotReceiveError < ::Spy::Error; end

class Spy::API::HaveReceived
  # @return [HaveReceived] a new instance of HaveReceived
  #
  # source://spy//lib/spy/api.rb#22
  def initialize(method_name); end

  # Returns the value of attribute actual.
  #
  # source://spy//lib/spy/api.rb#20
  def actual; end

  # source://spy//lib/spy/api.rb#52
  def description; end

  # source://spy//lib/spy/api.rb#44
  def failure_message_for_should; end

  # source://spy//lib/spy/api.rb#48
  def failure_message_for_should_not; end

  # @return [Boolean]
  #
  # source://spy//lib/spy/api.rb#27
  def matches?(actual); end

  # Returns the value of attribute method_name.
  #
  # source://spy//lib/spy/api.rb#20
  def method_name; end

  # source://spy//lib/spy/api.rb#39
  def with(*args, &block); end

  private

  # source://spy//lib/spy/api.rb#58
  def args_message; end

  # source://spy//lib/spy/api.rb#67
  def spy; end
end

# Manages all the spies
class Spy::Agency
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @private
  # @return [Agency] a new instance of Agency
  #
  # source://spy//lib/spy/agency.rb#9
  def initialize; end

  # checks to see if a spy is hooked
  #
  # @param spy [Subroutine, Constant, Double]
  # @return [Boolean]
  #
  # source://spy//lib/spy/agency.rb#40
  def active?(spy); end

  # clears records
  #
  # @return [self]
  #
  # source://spy//lib/spy/agency.rb#56
  def clear!; end

  # unhooks all spies and clears records
  #
  # @return [self]
  #
  # source://spy//lib/spy/agency.rb#47
  def dissolve!; end

  # given a spy ID it will return the associated spy
  #
  # @param id [Integer] spy object id
  # @return [Nil, Subroutine, Constant, Double]
  #
  # source://spy//lib/spy/agency.rb#16
  def find(id); end

  # Record that a spy was initialized and hooked
  #
  # @param spy [Subroutine, Constant, Double]
  # @raise [AlreadyStubbedError]
  # @return [spy]
  #
  # source://spy//lib/spy/agency.rb#23
  def recruit(spy); end

  # remove spy from the records
  #
  # @param spy [Subroutine, Constant, Double]
  # @raise [NoSpyError]
  # @return [spy]
  #
  # source://spy//lib/spy/agency.rb#32
  def retire(spy); end

  # returns all the spies that have been initialized since the creation of
  # this agency
  #
  # @return [Array<Subroutine, Constant, Double>]
  #
  # source://spy//lib/spy/agency.rb#64
  def spies; end

  private

  # @raise [ArgumentError]
  #
  # source://spy//lib/spy/agency.rb#70
  def check_spy!(spy); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

class Spy::AlreadyHookedError < ::Spy::Error; end
class Spy::AlreadyStubbedError < ::Spy::Error; end
module Spy::Base; end

class Spy::CallLog
  # @return [CallLog] a new instance of CallLog
  #
  # source://spy//lib/spy/call_log.rb#22
  def initialize(object, called_from, args, block, result); end

  # @return [Array] arguments were sent to the method
  #
  # source://spy//lib/spy/call_log.rb#20
  def args; end

  # @return [Proc] the block that was sent to the method
  #
  # source://spy//lib/spy/call_log.rb#20
  def block; end

  # @return [String] where the method was called from
  #
  # source://spy//lib/spy/call_log.rb#20
  def called_from; end

  # @return [Object] object that the method was called from
  #
  # source://spy//lib/spy/call_log.rb#20
  def object; end

  # @return The result of the method of being stubbed, or called through
  #
  # source://spy//lib/spy/call_log.rb#20
  def result; end
end

class Spy::Constant
  include ::Spy::Base

  # @param base_module [Module] the module this spy should be on
  # @param constant_name [Symbol] the constant this spy is watching
  # @raise [ArgumentError]
  # @return [Constant] a new instance of Constant
  #
  # source://spy//lib/spy/constant.rb#18
  def initialize(base_module, constant_name); end

  # unsets the constant
  #
  # @return [self]
  #
  # source://spy//lib/spy/constant.rb#60
  def and_hide; end

  # sets the constant to the requested value
  #
  # @param value [Object]
  # @return [self]
  #
  # source://spy//lib/spy/constant.rb#68
  def and_return(value); end

  # @return [Module] the module that is being watched
  #
  # source://spy//lib/spy/constant.rb#14
  def base_module; end

  # @return [Symbol] the name of the constant that is/will be stubbed
  #
  # source://spy//lib/spy/constant.rb#14
  def constant_name; end

  # checks to see if the constant is currently defined?
  #
  # @return [Boolean]
  #
  # source://spy//lib/spy/constant.rb#89
  def currently_defined?; end

  # checks to see if the constant is hidden?
  #
  # @return [Boolean]
  #
  # source://spy//lib/spy/constant.rb#83
  def hidden?; end

  # stashes the original constant then overwrites it with nil
  #
  # @param opts [Hash{force => false}] set :force => true if you want it to ignore if the constant exists
  # @return [self]
  #
  # source://spy//lib/spy/constant.rb#33
  def hook(opts = T.unsafe(nil)); end

  # checks to see if this spy is hooked?
  #
  # @return [Boolean]
  #
  # source://spy//lib/spy/constant.rb#77
  def hooked?; end

  # full name of spied constant
  #
  # source://spy//lib/spy/constant.rb#26
  def name; end

  # @return [Object] the original value that was set when it was hooked
  #
  # source://spy//lib/spy/constant.rb#14
  def original_value; end

  # checks to see if the constant is previously defined?
  #
  # @return [Boolean]
  #
  # source://spy//lib/spy/constant.rb#95
  def previously_defined?; end

  # restores the original value of the constant or unsets it if it was unset
  #
  # @return [self]
  #
  # source://spy//lib/spy/constant.rb#48
  def unhook; end

  class << self
    # retrieves the spy for given constnat and module or returns nil
    #
    # @return [Nil, Constant]
    #
    # source://spy//lib/spy/constant.rb#117
    def get(base_module, constant_name); end

    # retrieves the spy for given constant and module and unhooks the constant
    # from the module
    #
    # @raise [NoSpyError]
    # @return [Constant]
    #
    # source://spy//lib/spy/constant.rb#109
    def off(base_module, constant_name); end

    # finds existing spy or creates a new constant spy and hooks the constant
    #
    # @return [Constant]
    #
    # source://spy//lib/spy/constant.rb#102
    def on(base_module, constant_name); end
  end
end

class Spy::Error < ::StandardError; end

# A Mock is an object that has all the same methods as the given class.
# Each method however will raise a NeverHookedError if it hasn't been stubbed.
# If you attempt to stub a method on the mock that doesn't exist on the
# original class it will raise an error.
module Spy::Mock
  include ::Spy::Base

  # source://spy//lib/spy/mock.rb#11
  def initialize(&mock_method); end

  # the only method that doesn't work correctly of a mock if inherited. We
  # overwite for compatibility.
  #
  # @param other [Class]
  # @return [Boolean]
  #
  # source://spy//lib/spy/mock.rb#19
  def instance_of?(other); end

  # returns the original class method if the current method is a mock_method
  #
  # @param method_name [Symbol, String]
  # @return [Method]
  #
  # source://spy//lib/spy/mock.rb#26
  def method(method_name); end

  class << self
    # This will create a new Mock class with all the instance methods of given
    # klass mocked out.
    #
    # @param klass [Class]
    # @return [Class]
    #
    # source://spy//lib/spy/mock.rb#41
    def new(klass); end

    private

    # source://spy//lib/spy/mock.rb#102
    def args_for_method(method); end

    # source://spy//lib/spy/mock.rb#82
    def classes_to_override_methods(mod); end

    # source://spy//lib/spy/mock.rb#93
    def get_inherited_methods(klass_ancestors, visibility); end

    # @private
    #
    # source://spy//lib/spy/mock.rb#58
    def included(mod); end
  end
end

# source://spy//lib/spy/mock.rb#8
Spy::Mock::CLASSES_NOT_TO_OVERRIDE = T.let(T.unsafe(nil), Array)

# source://spy//lib/spy/mock.rb#9
Spy::Mock::METHODS_NOT_TO_OVERRIDE = T.let(T.unsafe(nil), Array)

# This class manages all the Constant Mutations for a given Module
class Spy::Nest
  # @raise [ArgumentError]
  # @return [Nest] a new instance of Nest
  #
  # source://spy//lib/spy/nest.rb#14
  def initialize(base_module); end

  # records that the spy is hooked
  #
  # @param spy [Constant]
  # @return [self]
  #
  # source://spy//lib/spy/nest.rb#23
  def add(spy); end

  # @return [Module] The module that the Nest is managing
  #
  # source://spy//lib/spy/nest.rb#12
  def base_module; end

  # returns a spy if the constant was added
  #
  # @param constant_name [Symbol]
  # @return [Constant, nil]
  #
  # source://spy//lib/spy/nest.rb#47
  def get(constant_name); end

  # checks to see if a given constant is hooked
  #
  # @param constant_name [Symbol]
  # @return [Boolean]
  #
  # source://spy//lib/spy/nest.rb#54
  def hooked?(constant_name); end

  # list all the constants that are being stubbed
  #
  # @return [Array]
  #
  # source://spy//lib/spy/nest.rb#60
  def hooked_constants; end

  # removes the spy from the records
  #
  # @param spy [Constant]
  # @return [self]
  #
  # source://spy//lib/spy/nest.rb#35
  def remove(spy); end

  class << self
    # returns all the hooked constants
    #
    # @return [Hash<String, Constant>]
    #
    # source://spy//lib/spy/nest.rb#81
    def all; end

    # retrieves the nest for a given module or creates it
    #
    # @param base_module [Module]
    # @return [Nest]
    #
    # source://spy//lib/spy/nest.rb#75
    def fetch(base_module); end

    # retrieves the nest for a given module
    #
    # @param base_module [Module]
    # @return [Nil, Nest]
    #
    # source://spy//lib/spy/nest.rb#68
    def get(base_module); end
  end
end

class Spy::NeverHookedError < ::Spy::Error; end
class Spy::NoSpyError < ::Spy::Error; end
class Spy::NotHookedError < ::Spy::Error; end

class Spy::Subroutine
  include ::Spy::Base

  # set what object and method the spy should watch
  #
  # @param object
  # @param method_name [Symbol]
  # @param singleton_method [Boolean] spy on the singleton method or the normal method
  # @return [Subroutine] a new instance of Subroutine
  #
  # source://spy//lib/spy/subroutine.rb#32
  def initialize(object, method_name, singleton_method = T.unsafe(nil)); end

  # tells the spy to call the original method
  #
  # @return [self]
  #
  # source://spy//lib/spy/subroutine.rb#151
  def and_call_through; end

  # Tells the object to raise an exception when the message is received.
  #
  # @note When you pass an exception class, the MessageExpectation will raise
  #   an instance of it, creating it with `exception` and passing `message`
  #   if specified.  If the exception class initializer requires more than
  #   one parameters, you must pass in an instance and not the class,
  #   otherwise this method will raise an ArgumentError exception.
  # @overload and_raise
  # @overload and_raise
  # @overload and_raise
  # @overload and_raise
  # @return [self]
  #
  # source://spy//lib/spy/subroutine.rb#173
  def and_raise(exception = T.unsafe(nil), message = T.unsafe(nil)); end

  # Tells the spy to return a value when the method is called.
  #
  # If a block is sent it will execute the block when the method is called.
  # The airty of the block will be checked against the original method when
  # you first call `and_return` and when the method is called.
  #
  # If you want to disable the arity checking just pass `{force: true}` to the
  # value
  #
  # @example
  #   spy.and_return(true)
  #   spy.and_return { true }
  #   spy.and_return(force: true) { |invalid_arity| true }
  # @overload and_return
  # @overload and_return
  # @return [self]
  #
  # source://spy//lib/spy/subroutine.rb#121
  def and_return(value = T.unsafe(nil), &block); end

  # Tells the object to throw a symbol (with the object if that form is
  # used) when the message is received.
  #
  # @overload and_throw
  # @overload and_throw
  # @return [self]
  #
  # source://spy//lib/spy/subroutine.rb#189
  def and_throw(*args); end

  # Tells the object to yield one or more args to a block when the message is received.
  #
  # @return [self]
  # @yield [eval_context = Object.new]
  #
  # source://spy//lib/spy/subroutine.rb#141
  def and_yield(*args); end

  # @return [Object] the object that is being watched
  #
  # source://spy//lib/spy/subroutine.rb#26
  def base_object; end

  # @return [Array<CallLog>] the messages that have been sent to the method
  #
  # source://spy//lib/spy/subroutine.rb#26
  def calls; end

  # if the method was called it will return true
  #
  # @raise [NeverHookedError]
  # @return [Boolean]
  #
  # source://spy//lib/spy/subroutine.rb#196
  def has_been_called?; end

  # check if the method was called with the exact arguments
  #
  # @param args Arguments that should have been sent to the method
  # @raise [NeverHookedError]
  # @return [Boolean]
  #
  # source://spy//lib/spy/subroutine.rb#204
  def has_been_called_with?(*args, &block); end

  # hooks the method into the object and stashes original method if it exists
  #
  # @option opts
  # @option opts
  # @param opts [Hash] what do do when hooking into a method
  # @raise [AlreadyHookedError]
  # @return [self]
  #
  # source://spy//lib/spy/subroutine.rb#45
  def hook(opts = T.unsafe(nil)); end

  # @return [Hash] the options that were sent when it was hooked
  #
  # source://spy//lib/spy/subroutine.rb#26
  def hook_opts; end

  # is the spy hooked?
  #
  # @return [Boolean]
  #
  # source://spy//lib/spy/subroutine.rb#99
  def hooked?; end

  # invoke that the method has been called. You really shouldn't use this
  # method.
  #
  # source://spy//lib/spy/subroutine.rb#212
  def invoke(object, args, block, called_from); end

  # @return [Symbol] the name of the method that is being watched
  #
  # source://spy//lib/spy/subroutine.rb#26
  def method_name; end

  # @return [Method] the original method that was hooked if it existed
  #
  # source://spy//lib/spy/subroutine.rb#26
  def original_method; end

  # @return [Method] the original visibility of the method that was hooked if it existed
  #
  # source://spy//lib/spy/subroutine.rb#26
  def original_method_visibility; end

  # reset the call log
  #
  # source://spy//lib/spy/subroutine.rb#227
  def reset!; end

  # @return [Boolean] if the spied method is a singleton_method or not
  #
  # source://spy//lib/spy/subroutine.rb#26
  def singleton_method; end

  # unhooks method from object
  #
  # @raise [NeverHookedError]
  # @return [self]
  #
  # source://spy//lib/spy/subroutine.rb#83
  def unhook; end

  private

  # source://spy//lib/spy/subroutine.rb#296
  def arity_range; end

  # source://spy//lib/spy/subroutine.rb#334
  def build_call_through_plan(object); end

  # source://spy//lib/spy/subroutine.rb#348
  def call_plan(plan, block, *args); end

  # source://spy//lib/spy/subroutine.rb#274
  def check_arity!(arity); end

  # source://spy//lib/spy/subroutine.rb#284
  def check_for_too_many_arguments!(block); end

  # source://spy//lib/spy/subroutine.rb#249
  def clear_method!; end

  # source://spy//lib/spy/subroutine.rb#326
  def current_method; end

  # source://spy//lib/spy/subroutine.rb#330
  def method_owner; end

  # source://spy//lib/spy/subroutine.rb#254
  def method_visibility_of(method_name, all = T.unsafe(nil)); end

  # source://spy//lib/spy/subroutine.rb#240
  def override_method; end

  # Ruby 2.7 gives a deprecation warning about passing hash as last argument for a method
  # with a double-splat operator (**), and Ruby 3 raises an ArgumentError exception.
  # This checks if args has a hash as last element to extract it and pass it with double-splat to avoid an exception.
  #
  # @return [Boolean]
  #
  # source://spy//lib/spy/subroutine.rb#360
  def ruby_27_last_arg_hash?(args); end

  class << self
    # retrieve the method spy from an object or return nil
    #
    # @param base_object
    # @param method_name [Symbol]
    # @param singleton_method [Boolean] this a singleton method or a instance method?
    # @return [Array<Subroutine>]
    #
    # source://spy//lib/spy/subroutine.rb#389
    def get(base_object, method_name, singleton_method = T.unsafe(nil)); end

    # retrieve all the spies from a given object
    #
    # @param base_object
    # @param singleton_method [Boolean] (true) only get singleton_method_spies
    # @return [Array<Subroutine>]
    #
    # source://spy//lib/spy/subroutine.rb#409
    def get_spies(base_object, singleton_methods = T.unsafe(nil)); end

    # @private
    #
    # source://spy//lib/spy/subroutine.rb#427
    def get_spy_id(method); end

    # @raise [NoSpyError]
    #
    # source://spy//lib/spy/subroutine.rb#378
    def off(base_object, method_name, singleton_method = T.unsafe(nil)); end

    # retrieve the method spy from an object or create a new one
    #
    # @param base_object
    # @param method_name [Symbol]
    # @param singleton_method [Boolean] this a singleton method or a instance method?
    # @return [Array<Subroutine>]
    #
    # source://spy//lib/spy/subroutine.rb#374
    def on(base_object, method_name, singleton_method = T.unsafe(nil)); end
  end
end

# this returns a lambda that calls the spy object.
# we use eval to set the spy object id as a parameter so it can be extracted
# and looked up later using `Method#parameters`
#
# source://spy//lib/spy/subroutine.rb#239
Spy::Subroutine::SPY_ARGS_PREFIX = T.let(T.unsafe(nil), String)

# source://spy//lib/spy/version.rb#2
Spy::VERSION = T.let(T.unsafe(nil), String)
