# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `yard-sorbet` gem.
# Please instead update this file by running `bin/tapioca gem yard-sorbet`.

# +Base+ is the superclass of all code objects recognized by YARD. A code
# object is any entity in the Ruby language (class, method, module). A
# DSL might subclass +Base+ to create a new custom object representing
# a new entity type.
#
# == Registry Integration
# Any created object associated with a namespace is immediately registered
# with the registry. This allows the Registry to act as an identity map
# to ensure that no object is represented by more than one Ruby object
# in memory. A unique {#path} is essential for this identity map to work
# correctly.
#
# == Custom Attributes
# Code objects allow arbitrary custom attributes to be set using the
# {#[]=} assignment method.
#
# == Namespaces
# There is a special type of object called a "namespace". These are subclasses
# of the {NamespaceObject} and represent Ruby entities that can have
# objects defined within them. Classically these are modules and classes,
# though a DSL might create a custom {NamespaceObject} to describe a
# specific set of objects.
#
# == Separators
# Custom classes with different separator tokens should define their own
# separators using the {NamespaceMapper.register_separator} method. The
# standard Ruby separators have already been defined ('::', '#', '.', etc).
#
# @abstract This class should not be used directly. Instead, create a
#   subclass that implements {#path}, {#sep} or {#type}. You might also
#   need to register custom separators if {#sep} uses alternate separator
#   tokens.
# @see Registry
# @see #path
# @see #[]=
# @see NamespaceObject
# @see NamespaceMapper.register_separator
class YARD::CodeObjects::Base
  # Creates a new code object
  #
  # @example Create a method in the root namespace
  #   CodeObjects::Base.new(:root, '#method') # => #<yardoc method #method>
  # @example Create class Z inside namespace X::Y
  #   CodeObjects::Base.new(P("X::Y"), :Z) # or
  #   CodeObjects::Base.new(Registry.root, "X::Y")
  # @param namespace [NamespaceObject] the namespace the object belongs in,
  #   {Registry.root} or :root should be provided if it is associated with
  #   the top level namespace.
  # @param name [Symbol, String] the name (or complex path) of the object.
  # @return [Base] the newly created object
  # @yield [self] a block to perform any extra initialization on the object
  # @yieldparam self [Base] the newly initialized code object
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#238
  def initialize(namespace, name, *_arg2); end

  # Tests if another object is equal to this, including a proxy
  #
  # @param other [Base, Proxy] if other is a {Proxy}, tests if
  #   the paths are equal
  # @return [Boolean] whether or not the objects are considered the same
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#322
  def ==(other); end

  # Accesses a custom attribute on the object
  #
  # @param key [#to_s] the name of the custom attribute
  # @return [Object, nil] the custom attribute or nil if not found.
  # @see #[]=
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#342
  def [](key); end

  # Sets a custom attribute on the object
  #
  # @param key [#to_s] the name of the custom attribute
  # @param value [Object] the value to associate
  # @return [void]
  # @see #[]
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#355
  def []=(key, value); end

  # Associates a file with a code object, optionally adding the line where it was defined.
  # By convention, '<stdin>' should be used to associate code that comes form standard input.
  #
  # @param file [String] the filename ('<stdin>' for standard input)
  # @param line [Fixnum, nil] the line number where the object lies in the file
  # @param has_comments [Boolean] whether or not the definition has comments associated. This
  #   will allow {#file} to return the definition where the comments were made instead
  #   of any empty definitions that might have been parsed before (module namespaces for instance).
  # @raise [ArgumentError]
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#290
  def add_file(file, line = T.unsafe(nil), has_comments = T.unsafe(nil)); end

  # Add tags to the {#docstring}
  #
  # @see Docstring#add_tag
  # @since 0.8.4
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#557
  def add_tag(*tags); end

  # The non-localized documentation string associated with the object
  #
  # @return [Docstring] the documentation string
  # @since 0.8.4
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#166
  def base_docstring; end

  # Copies all data in this object to another code object, except for
  # uniquely identifying information (path, namespace, name, scope).
  #
  # @param other [Base] the object to copy data to
  # @return [Base] the other object
  # @since 0.8.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#263
  def copy_to(other); end

  # The documentation string associated with the object
  #
  # @param locale [String, I18n::Locale] (I18n::Locale.default)
  #   the locale of the documentation string.
  # @return [Docstring] the documentation string
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#404
  def docstring(locale = T.unsafe(nil)); end

  # Attaches a docstring to a code object by parsing the comments attached to the statement
  # and filling the {#tags} and {#docstring} methods with the parsed information.
  #
  # @param comments [String, Array<String>, Docstring] the comments attached to the code object to be parsed
  #   into a docstring and meta tags.
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#426
  def docstring=(comments); end

  # Marks whether or not the method is conditionally defined at runtime
  #
  # @return [Boolean] true if the method is conditionally defined at runtime
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#170
  def dynamic; end

  # Marks whether or not the method is conditionally defined at runtime
  #
  # @return [Boolean] true if the method is conditionally defined at runtime
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#170
  def dynamic=(_arg0); end

  # Is the object defined conditionally at runtime?
  #
  # @return [Boolean]
  # @see #dynamic
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#178
  def dynamic?; end

  # Tests if another object is equal to this, including a proxy
  #
  # @param other [Base, Proxy] if other is a {Proxy}, tests if
  #   the paths are equal
  # @return [Boolean] whether or not the objects are considered the same
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#322
  def eql?(other); end

  # Tests if another object is equal to this, including a proxy
  #
  # @param other [Base, Proxy] if other is a {Proxy}, tests if
  #   the paths are equal
  # @return [Boolean] whether or not the objects are considered the same
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#322
  def equal?(other); end

  # Returns the filename the object was first parsed at, taking
  # definitions with docstrings first.
  #
  # @return [String] a filename
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#306
  def file; end

  # The files the object was defined in. To add a file, use {#add_file}.
  #
  # @return [Array<Array(String, Integer)>] a list of files
  # @see #add_file
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#137
  def files; end

  # Renders the object using the {Templates::Engine templating system}.
  #
  # @example Formats a class in plaintext
  #   puts P('MyClass').format
  # @example Formats a method in html with rdoc markup
  #   puts P('MyClass#meth').format(:format => :html, :markup => :rdoc)
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] a set of options to pass to the template
  # @return [String] the rendered template
  # @see Templates::Engine#render
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#501
  def format(options = T.unsafe(nil)); end

  # @return [String] the group this object is associated with
  # @since 0.6.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#174
  def group; end

  # @return [String] the group this object is associated with
  # @since 0.6.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#174
  def group=(_arg0); end

  # Tests if the {#docstring} has a tag
  #
  # @return [Boolean]
  # @see Docstring#has_tag?
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#552
  def has_tag?(name); end

  # @return [Integer] the object's hash value (for equality checking)
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#333
  def hash; end

  # Inspects the object, returning the type and path
  #
  # @return [String] a string describing the object
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#509
  def inspect; end

  # Returns the line the object was first parsed at (or nil)
  #
  # @return [Fixnum] the line where the object was first defined.
  # @return [nil] if there is no line associated with the object
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#314
  def line; end

  # @overload dynamic_attr_name
  # @overload dynamic_attr_name=
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#372
  def method_missing(meth, *args, &block); end

  # The name of the object
  #
  # @param prefix [Boolean] whether to show a prefix. Implement
  #   this in a subclass to define how the prefix is showed.
  # @return [Symbol] if prefix is false, the symbolized name
  # @return [String] if prefix is true, prefix + the name as a String.
  #   This must be implemented by the subclass.
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#278
  def name(prefix = T.unsafe(nil)); end

  # The namespace the object is defined in. If the object is in the
  # top level namespace, this is {Registry.root}
  #
  # @return [NamespaceObject] the namespace object
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#142
  def namespace; end

  # Sets the namespace the object is defined in.
  #
  # @param obj [NamespaceObject, :root, nil] the new namespace (:root
  #   for {Registry.root}). If obj is nil, the object is unregistered
  #   from the Registry.
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#518
  def namespace=(obj); end

  # The namespace the object is defined in. If the object is in the
  # top level namespace, this is {Registry.root}
  #
  # @return [NamespaceObject] the namespace object
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#142
  def parent; end

  # Sets the namespace the object is defined in.
  #
  # @param obj [NamespaceObject, :root, nil] the new namespace (:root
  #   for {Registry.root}). If obj is nil, the object is unregistered
  #   from the Registry.
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#518
  def parent=(obj); end

  # Represents the unique path of the object. The default implementation
  # joins the path of {#namespace} with {#name} via the value of {#sep}.
  # Custom code objects should ensure that the path is unique to the code
  # object by either overriding {#sep} or this method.
  #
  # @example The path of an instance method
  #   MethodObject.new(P("A::B"), :c).path # => "A::B#c"
  # @return [String] the unique path of the object
  # @see #sep
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#449
  def path; end

  # @param other [Base, String] another code object (or object path)
  # @return [String] the shortest relative path from this object to +other+
  # @since 0.5.3
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#471
  def relative_path(other); end

  # @return [Boolean] whether or not this object is a RootObject
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#563
  def root?; end

  # Override this method with a custom component separator. For instance,
  # {MethodObject} implements sep as '#' or '.' (depending on if the
  # method is instance or class respectively). {#path} depends on this
  # value to generate the full path in the form: namespace.path + sep + name
  #
  # @return [String] the component that separates the namespace path
  #   and the name (default is {NSEP})
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#572
  def sep; end

  # The one line signature representing an object. For a method, this will
  # be of the form "def meth(arguments...)". This is usually the first
  # source line.
  #
  # @return [String] a line of source
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#159
  def signature; end

  # The one line signature representing an object. For a method, this will
  # be of the form "def meth(arguments...)". This is usually the first
  # source line.
  #
  # @return [String] a line of source
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#159
  def signature=(_arg0); end

  # The source code associated with the object
  #
  # @return [String, nil] source, if present, or nil
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#146
  def source; end

  # Attaches source code to a code object with an optional file location
  #
  # @param statement [#source, String] the +Parser::Statement+ holding the source code or the raw source
  #   as a +String+ for the definition of the code object only (not the block)
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#387
  def source=(statement); end

  # Language of the source code associated with the object. Defaults to
  # +:ruby+.
  #
  # @return [Symbol] the language type
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#152
  def source_type; end

  # Language of the source code associated with the object. Defaults to
  # +:ruby+.
  #
  # @return [Symbol] the language type
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#152
  def source_type=(_arg0); end

  # Gets a tag from the {#docstring}
  #
  # @see Docstring#tag
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#544
  def tag(name); end

  # Gets a list of tags from the {#docstring}
  #
  # @see Docstring#tags
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#548
  def tags(name = T.unsafe(nil)); end

  # @note Override this method if your object has a special title that does
  #   not match the {#path} attribute value. This title will be used
  #   when linking or displaying the object.
  # @return [String] the display title for an object
  # @see 0.8.4
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#464
  def title; end

  # @return [nil] this object does not turn into an array
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#336
  def to_ary; end

  # Represents the unique path of the object. The default implementation
  # joins the path of {#namespace} with {#name} via the value of {#sep}.
  # Custom code objects should ensure that the path is unique to the code
  # object by either overriding {#sep} or this method.
  #
  # @example The path of an instance method
  #   MethodObject.new(P("A::B"), :c).path # => "A::B#c"
  # @return [String] the unique path of the object
  # @see #sep
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#449
  def to_s; end

  # Default type is the lowercase class name without the "Object" suffix.
  # Override this method to provide a custom object type
  #
  # @return [Symbol] the type of code object this represents
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#436
  def type; end

  # @return [Symbol] the visibility of an object (:public, :private, :protected)
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#181
  def visibility; end

  # @return [Symbol] the visibility of an object (:public, :private, :protected)
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#183
  def visibility=(v); end

  protected

  # Override this method if your code object subclass does not allow
  # copying of certain attributes.
  #
  # @return [Array<String>] the list of instance variable names (without
  #   "@" prefix) that should be copied when {#copy_to} is called
  # @see #copy_to
  # @since 0.8.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#583
  def copyable_attributes; end

  private

  # Formats source code by removing leading indentation
  #
  # @param source [String] the source code to format
  # @return [String] formatted source
  #
  # source://yard/0.9.28/lib/yard/code_objects/base.rb#595
  def format_source(source); end

  # source://yard/0.9.28/lib/yard/code_objects/base.rb#602
  def translate_docstring(locale); end

  class << self
    # Compares the class with subclasses
    #
    # @param other [Object] the other object to compare classes with
    # @return [Boolean] true if other is a subclass of self
    #
    # source://yard/0.9.28/lib/yard/code_objects/base.rb#219
    def ===(other); end

    # Allocates a new code object
    #
    # @raise [ArgumentError]
    # @return [Base]
    # @see #initialize
    # @yield [obj]
    #
    # source://yard/0.9.28/lib/yard/code_objects/base.rb#189
    def new(namespace, name, *args, &block); end
  end
end

# A ClassObject represents a Ruby class in source code. It is a {ModuleObject}
# with extra inheritance semantics through the superclass.
class YARD::CodeObjects::ClassObject < ::YARD::CodeObjects::NamespaceObject
  # Creates a new class object in +namespace+ with +name+
  #
  # @return [ClassObject] a new instance of ClassObject
  # @see Base.new
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#15
  def initialize(namespace, name, *args, &block); end

  # Returns the list of constants matching the options hash.
  #
  # @option opts
  # @option opts
  # @param opts [Hash] the options hash to match
  # @return [Array<ConstantObject>] the list of constant that matched
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#101
  def constants(opts = T.unsafe(nil)); end

  # Returns the inheritance tree of the object including self.
  #
  # @param include_mods [Boolean] whether or not to include mixins in the
  #   inheritance tree.
  # @return [Array<NamespaceObject>] the list of code objects that make up
  #   the inheritance tree.
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#45
  def inheritance_tree(include_mods = T.unsafe(nil)); end

  # Returns only the constants that were inherited.
  #
  # @return [Array<ConstantObject>] the list of inherited constant objects
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#109
  def inherited_constants; end

  # Returns only the methods that were inherited.
  #
  # @return [Array<MethodObject>] the list of inherited method objects
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#79
  def inherited_meths(opts = T.unsafe(nil)); end

  # Whether or not the class is a Ruby Exception
  #
  # @return [Boolean] whether the object represents a Ruby exception
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#35
  def is_exception?; end

  # Returns the list of methods matching the options hash. Returns
  # all methods if hash is empty.
  #
  # @option opts
  # @option opts
  # @param opts [Hash] the options hash to match
  # @return [Array<MethodObject>] the list of methods that matched
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#66
  def meths(opts = T.unsafe(nil)); end

  # The {ClassObject} that this class object inherits from in Ruby source.
  #
  # @return [ClassObject] a class object that is the superclass of this one
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#10
  def superclass; end

  # Sets the superclass of the object
  #
  # @param object [Base, Proxy, String, Symbol, nil] the superclass value
  # @return [void]
  #
  # source://yard/0.9.28/lib/yard/code_objects/class_object.rb#125
  def superclass=(object); end
end

# Represents a Ruby method in source
class YARD::CodeObjects::MethodObject < ::YARD::CodeObjects::Base
  # Creates a new method object in +namespace+ with +name+ and an instance
  # or class +scope+
  #
  # If scope is +:module+, this object is instantiated as a public
  # method in +:class+ scope, but also creates a new (empty) method
  # as a private +:instance+ method on the same class or module.
  #
  # @param namespace [NamespaceObject] the namespace
  # @param name [String, Symbol] the method name
  # @param scope [Symbol] +:instance+, +:class+, or +:module+
  # @return [MethodObject] a new instance of MethodObject
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#37
  def initialize(namespace, name, scope = T.unsafe(nil), &block); end

  # Returns all alias names of the object
  #
  # @return [Array<MethodObject>] the alias names
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#149
  def aliases; end

  # Returns the read/writer info for the attribute if it is one
  #
  # @return [SymbolHash] if there is information about the attribute
  # @return [nil] if the method is not an attribute
  # @since 0.5.3
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#93
  def attr_info; end

  # @return [Boolean] whether or not the method is the #initialize constructor method
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#78
  def constructor?; end

  # Whether the object is explicitly defined in source or whether it was
  # inferred by a handler. For instance, attribute methods are generally
  # inferred and therefore not explicitly defined in source.
  #
  # @return [Boolean] whether the object is explicitly defined in source.
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#18
  def explicit; end

  # Whether the object is explicitly defined in source or whether it was
  # inferred by a handler. For instance, attribute methods are generally
  # inferred and therefore not explicitly defined in source.
  #
  # @return [Boolean] whether the object is explicitly defined in source.
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#18
  def explicit=(_arg0); end

  # Tests if the object is defined as an alias of another method
  #
  # @return [Boolean] whether the object is an alias
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#126
  def is_alias?; end

  # Tests if the object is defined as an attribute in the namespace
  #
  # @return [Boolean] whether the object is an attribute
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#114
  def is_attribute?; end

  # Tests boolean {#explicit} value.
  #
  # @return [Boolean] whether the method is explicitly defined in source
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#134
  def is_explicit?; end

  # @return [Boolean] whether or not this method was created as a module
  #   function
  # @since 0.8.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#85
  def module_function?; end

  # Returns the name of the object.
  #
  # @example The name of an instance method (with prefix)
  #   an_instance_method.name(true) # => "#mymethod"
  # @example The name of a class method (with prefix)
  #   a_class_method.name(true) # => "mymethod"
  # @param prefix [Boolean] whether or not to show the prefix
  # @return [String] returns {#sep} + +name+ for an instance method if
  #   prefix is true
  # @return [Symbol] the name without {#sep} if prefix is set to false
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#175
  def name(prefix = T.unsafe(nil)); end

  # @return [MethodObject] the object that this method overrides
  # @return [nil] if it does not override a method
  # @since 0.6.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#141
  def overridden_method; end

  # Returns the list of parameters parsed out of the method signature
  # with their default values.
  #
  # @return [Array<Array(String, String)>] a list of parameter names followed
  #   by their default values (or nil)
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#25
  def parameters; end

  # Returns the list of parameters parsed out of the method signature
  # with their default values.
  #
  # @return [Array<Array(String, String)>] a list of parameter names followed
  #   by their default values (or nil)
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#25
  def parameters=(_arg0); end

  # Override path handling for instance methods in the root namespace
  # (they should still have a separator as a prefix).
  #
  # @return [String] the path of a method
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#161
  def path; end

  # @return [Boolean] whether the method is a reader attribute
  # @since 0.5.3
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#107
  def reader?; end

  # The scope of the method (+:class+ or +:instance+)
  #
  # @return [Symbol] the scope
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#11
  def scope; end

  # Changes the scope of an object from :instance or :class
  #
  # @param v [Symbol] the new scope
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#58
  def scope=(v); end

  # Override separator to differentiate between class and instance
  # methods.
  #
  # @return [String] "#" for an instance method, "." for class
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#182
  def sep; end

  # @return [Boolean] whether the method is a writer attribute
  # @since 0.5.3
  #
  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#100
  def writer?; end

  protected

  # source://yard/0.9.28/lib/yard/code_objects/method_object.rb#192
  def copyable_attributes; end
end

# A "namespace" is any object that can store other objects within itself.
# The two main Ruby objects that can act as namespaces are modules
# ({ModuleObject}) and classes ({ClassObject}).
class YARD::CodeObjects::NamespaceObject < ::YARD::CodeObjects::Base
  # Creates a new namespace object inside +namespace+ with +name+.
  #
  # @return [NamespaceObject] a new instance of NamespaceObject
  # @see Base#initialize
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#56
  def initialize(namespace, name, *args, &block); end

  # A hash containing two keys, :class and :instance, each containing
  # a hash of objects and their alias names.
  #
  # @return [Hash] a list of methods
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#44
  def aliases; end

  # A hash containing two keys, class and instance, each containing
  # the attribute name with a { :read, :write } hash for the read and
  # write objects respectively.
  #
  # @example The attributes of an object
  #   >> Registry.at('YARD::Docstring').attributes
  #   => {
  #   :class => { },
  #   :instance => {
  #   :ref_tags => {
  #   :read => #<yardoc method YARD::Docstring#ref_tags>,
  #   :write => nil
  #   },
  #   :object => {
  #   :read => #<yardoc method YARD::Docstring#object>,
  #   :write => #<yardoc method YARD::Docstring#object=>
  #   },
  #   ...
  #   }
  #   }
  # @return [Hash] a list of methods
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#39
  def attributes; end

  # Looks for a child that matches the attributes specified by +opts+.
  #
  # @example Finds a child by name and scope
  #   namespace.child(:name => :to_s, :scope => :instance)
  #   # => #<yardoc method MyClass#to_s>
  # @return [Base, nil] the first matched child object, or nil
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#86
  def child(opts = T.unsafe(nil)); end

  # The list of objects defined in this namespace
  #
  # @return [Array<Base>] a list of objects
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#16
  def children; end

  # Only the class attributes
  #
  # @return [Hash] a list of method names and their read/write objects
  # @see #attributes
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#69
  def class_attributes; end

  # Class mixins
  #
  # @return [Array<ModuleObject>] a list of mixins
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#48
  def class_mixins; end

  # Returns all constants in the namespace
  #
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Array<ConstantObject>] a list of constant objects
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#164
  def constants(opts = T.unsafe(nil)); end

  # Returns class variables defined in this namespace.
  #
  # @return [Array<ClassVariableObject>] a list of class variable objects
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#186
  def cvars; end

  # @return [Array<String>] a list of ordered group names inside the namespace
  # @since 0.6.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#12
  def groups; end

  # @return [Array<String>] a list of ordered group names inside the namespace
  # @since 0.6.0
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#12
  def groups=(_arg0); end

  # Returns constants included from any mixins
  #
  # @return [Array<ConstantObject>] a list of constant objects
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#172
  def included_constants; end

  # Returns methods included from any mixins that match the attributes
  # specified by +opts+. If no options are specified, returns all included
  # methods.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @see #meths
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#144
  def included_meths(opts = T.unsafe(nil)); end

  # Only the instance attributes
  #
  # @return [Hash] a list of method names and their read/write objects
  # @see #attributes
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#76
  def instance_attributes; end

  # Instance mixins
  #
  # @return [Array<ModuleObject>] a list of mixins
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#52
  def instance_mixins; end

  # Returns all methods that match the attributes specified by +opts+. If
  # no options are provided, returns all methods.
  #
  # @example Finds all private and protected class methods
  #   namespace.meths(:visibility => [:private, :protected], :scope => :class)
  #   # => [#<yardoc method MyClass.privmeth>, #<yardoc method MyClass.protmeth>]
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Array<MethodObject>] a list of method objects
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#113
  def meths(opts = T.unsafe(nil)); end

  # Returns for specific scopes. If no scopes are provided, returns all mixins.
  #
  # @param scopes [Array<Symbol>] a list of scopes (:class, :instance) to
  #   return mixins for. If this is empty, all scopes will be returned.
  # @return [Array<ModuleObject>] a list of mixins
  #
  # source://yard/0.9.28/lib/yard/code_objects/namespace_object.rb#194
  def mixins(*scopes); end
end

# A documentation string, or "docstring" for short, encapsulates the
# comments and metadata, or "tags", of an object. Meta-data is expressed
# in the form +@tag VALUE+, where VALUE can span over multiple lines as
# long as they are indented. The following +@example+ tag shows how tags
# can be indented:
#
#   # @example My example
#   #   a = "hello world"
#   #   a.reverse
#   # @version 1.0
#
# Tags can be nested in a documentation string, though the {Tags::Tag}
# itself is responsible for parsing the inner tags.
class YARD::Docstring < ::String
  # Creates a new docstring with the raw contents attached to an optional
  # object. Parsing will be done by the {DocstringParser} class.
  #
  # @example
  #   Docstring.new("hello world\n@return Object return", someobj)
  # @note To properly parse directives with proper parser context within
  #   handlers, you should not use this method to create a Docstring.
  #   Instead, use the {parser}, which takes a handler object that
  #   can pass parser state onto directives. If a Docstring is created
  #   with this method, directives do not have access to any parser
  #   state, and may not function as expected.
  # @param content [String] the raw comments to be parsed into a docstring
  #   and associated meta-data.
  # @param object [CodeObjects::Base] an object to associate the docstring
  #   with.
  # @return [Docstring] a new instance of Docstring
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#103
  def initialize(content = T.unsafe(nil), object = T.unsafe(nil)); end

  # Adds another {Docstring}, copying over tags.
  #
  # @param other [Docstring, String] the other docstring (or string) to
  #   add.
  # @return [Docstring] a new docstring with both docstrings combines
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#116
  def +(other); end

  # Adds a tag or reftag object to the tag list. If you want to parse
  # tag data based on the {Tags::DefaultFactory} tag factory, use
  # {DocstringParser} instead.
  #
  # @param tags [Tags::Tag, Tags::RefTag] list of tag objects to add
  # @return [void]
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#242
  def add_tag(*tags); end

  # @return [String] the raw documentation (including raw tag text)
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#53
  def all; end

  # Replaces the docstring with new raw content. Called by {#all=}.
  #
  # @param content [String] the raw comments to be parsed
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#132
  def all=(content, parse = T.unsafe(nil)); end

  # Returns true if the docstring has no content that is visible to a template.
  #
  # @param only_visible_tags [Boolean] whether only {Tags::Library.visible_tags}
  #   should be checked, or if all tags should be considered.
  # @return [Boolean] whether or not the docstring has content
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#310
  def blank?(only_visible_tags = T.unsafe(nil)); end

  # Deletes all tags where the block returns true
  #
  # @return [void]
  # @since 0.7.0
  # @yieldparam tag [Tags::Tag] the tag that is being tested
  # @yieldreturn [Boolean] true if the tag should be deleted
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#300
  def delete_tag_if(&block); end

  # Delete all tags with +name+
  #
  # @param name [String] the tag name
  # @return [void]
  # @since 0.7.0
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#291
  def delete_tags(name); end

  # Deep-copies a docstring
  #
  # @note This method creates a new docstring with new tag lists, but does
  #   not create new individual tags. Modifying the tag objects will still
  #   affect the original tags.
  # @return [Docstring] a new copied docstring
  # @since 0.7.0
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#153
  def dup; end

  # Returns true if at least one tag by the name +name+ was declared
  #
  # @param name [String] the tag name to search for
  # @return [Boolean] whether or not the tag +name+ was declared
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#283
  def has_tag?(name); end

  # @return [Boolean] whether the docstring was started with "##"
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#56
  def hash_flag; end

  # source://yard/0.9.28/lib/yard/docstring.rb#57
  def hash_flag=(v); end

  # @return [Fixnum] the first line of the {#line_range}
  # @return [nil] if there is no associated {#line_range}
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#167
  def line; end

  # @return [Range] line range in the {#object}'s file where the docstring was parsed from
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#50
  def line_range; end

  # @return [Range] line range in the {#object}'s file where the docstring was parsed from
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#50
  def line_range=(_arg0); end

  # @return [CodeObjects::Base] the object that owns the docstring.
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#47
  def object; end

  # @return [CodeObjects::Base] the object that owns the docstring.
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#47
  def object=(_arg0); end

  # @return [Array<Tags::RefTag>] the list of reference tags
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#44
  def ref_tags; end

  # Replaces the docstring with new raw content. Called by {#all=}.
  #
  # @param content [String] the raw comments to be parsed
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#132
  def replace(content, parse = T.unsafe(nil)); end

  # Resolves unresolved other docstring reference if there is
  # unresolved reference. Does nothing if there is no unresolved
  # reference.
  #
  # Normally, you don't need to call this method
  # explicitly. Resolving unresolved reference is done implicitly.
  #
  # @return [void]
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#328
  def resolve_reference; end

  # Gets the first line of a docstring to the period or the first paragraph.
  #
  # @return [String] The first line or paragraph of the docstring; always ends with a period.
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#173
  def summary; end

  # Convenience method to return the first tag
  # object in the list of tag objects of that name
  #
  # @example
  #   doc = Docstring.new("@return zero when nil")
  #   doc.tag(:return).text  # => "zero when nil"
  # @param name [#to_s] the tag name to return data for
  # @return [Tags::Tag] the first tag in the list of {#tags}
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#265
  def tag(name); end

  # Returns a list of tags specified by +name+ or all tags if +name+ is not specified.
  #
  # @param name [#to_s] the tag name to return data for, or nil for all tags
  # @return [Array<Tags::Tag>] the list of tags by the specified tag name
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#273
  def tags(name = T.unsafe(nil)); end

  # Reformats and returns a raw representation of the tag data using the
  # current tag and docstring data, not the original text.
  #
  # @return [String] the updated raw formatted docstring data
  # @since 0.7.0
  # @todo Add Tags::Tag#to_raw and refactor
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#207
  def to_raw; end

  # source://yard/0.9.28/lib/yard/docstring.rb#125
  def to_s; end

  private

  # Maps valid reference tags
  #
  # @return [Array<Tags::RefTag>] the list of valid reference tags
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#344
  def convert_ref_tags; end

  # Parses out comments split by newlines into a new code object
  #
  # @param comments [String] the newline delimited array of comments. If the comments
  #   are passed as a String, they will be split by newlines.
  # @return [String] the non-metadata portion of the comments to
  #   be used as a docstring
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#369
  def parse_comments(comments); end

  # A stable sort_by method.
  #
  # @param list [Enumerable] the list to sort.
  # @return [Array] a stable sorted list.
  #
  # source://yard/0.9.28/lib/yard/docstring.rb#382
  def stable_sort_by(list); end

  class << self
    # @note Plugin developers should make sure to reset this value
    #   after parsing finishes. This can be done via the
    #   {Parser::SourceParser.after_parse_list} callback. This will
    #   ensure that YARD can properly parse multiple projects in
    #   the same process.
    # @return [Class<DocstringParser>] the parser class used to parse
    #   text and optional meta-data from docstrings. Defaults to
    #   {DocstringParser}.
    # @see DocstringParser
    # @see Parser::SourceParser.after_parse_list
    #
    # source://yard/0.9.28/lib/yard/docstring.rb#28
    def default_parser; end

    # @note Plugin developers should make sure to reset this value
    #   after parsing finishes. This can be done via the
    #   {Parser::SourceParser.after_parse_list} callback. This will
    #   ensure that YARD can properly parse multiple projects in
    #   the same process.
    # @return [Class<DocstringParser>] the parser class used to parse
    #   text and optional meta-data from docstrings. Defaults to
    #   {DocstringParser}.
    # @see DocstringParser
    # @see Parser::SourceParser.after_parse_list
    #
    # source://yard/0.9.28/lib/yard/docstring.rb#28
    def default_parser=(_arg0); end

    # Creates a new docstring without performing any parsing through
    # a {DocstringParser}. This method is called by +DocstringParser+
    # when creating the new docstring object.
    #
    # @param text [String] the textual portion of the docstring
    # @param tags [Array<Tags::Tag>] the list of tag objects in the docstring
    # @param object [CodeObjects::Base, nil] the object associated with the
    #   docstring. May be nil.
    # @param raw_data [String] the complete docstring, including all
    #   original formatting and any unparsed tags/directives.
    # @param ref_object [CodeObjects::Base, nil] a reference object used for
    #   the base set of documentation / tag information.
    #
    # source://yard/0.9.28/lib/yard/docstring.rb#77
    def new!(text, tags = T.unsafe(nil), object = T.unsafe(nil), raw_data = T.unsafe(nil), ref_object = T.unsafe(nil)); end

    # Creates a parser object using the current {default_parser}.
    # Equivalent to:
    #   Docstring.default_parser.new(*args)
    #
    # @param args arguments are passed to the {DocstringParser}
    #   class. See {DocstringParser#initialize} for details on
    #   arguments.
    # @return [DocstringParser] the parser object used to parse a
    #   docstring.
    #
    # source://yard/0.9.28/lib/yard/docstring.rb#38
    def parser(*args); end
  end
end

# Matches a tag at the start of a comment line
#
# @deprecated Use {DocstringParser::META_MATCH}
#
# source://yard/0.9.28/lib/yard/docstring.rb#61
YARD::Docstring::META_MATCH = T.let(T.unsafe(nil), Regexp)

class YARD::Handlers::Ruby::ClassHandler < ::YARD::Handlers::Ruby::Base
  include ::YARDSorbet::Handlers::StructClassHandler
end

# Types are documentation
#
# source://yard-sorbet//lib/yard-sorbet/version.rb#5
module YARDSorbet; end

# Extract & re-add directives to a docstring
#
# source://yard-sorbet//lib/yard-sorbet/directives.rb#6
module YARDSorbet::Directives
  class << self
    # source://yard-sorbet//lib/yard-sorbet/directives.rb#21
    sig { params(docstring: ::String, directives: T::Array[::String]).void }
    def add_directives(docstring, directives); end

    # source://yard-sorbet//lib/yard-sorbet/directives.rb#10
    sig { params(docstring: T.nilable(::String)).returns([::YARD::Docstring, T::Array[::String]]) }
    def extract_directives(docstring); end
  end
end

# Custom YARD Handlers
#
# @see https://rubydoc.info/gems/yard/YARD/Handlers/Base YARD Base Handler documentation
#
# source://yard-sorbet//lib/yard-sorbet/handlers.rb#7
module YARDSorbet::Handlers; end

# Apllies an `@abstract` tag to `abstract!`/`interface!` modules (if not alerady present).
#
# source://yard-sorbet//lib/yard-sorbet/handlers/abstract_dsl_handler.rb#7
class YARDSorbet::Handlers::AbstractDSLHandler < ::YARD::Handlers::Ruby::Base
  # source://yard-sorbet//lib/yard-sorbet/handlers/abstract_dsl_handler.rb#21
  sig { void }
  def process; end
end

# Extra text for class namespaces
#
# source://yard-sorbet//lib/yard-sorbet/handlers/abstract_dsl_handler.rb#18
YARDSorbet::Handlers::AbstractDSLHandler::CLASS_TAG_TEXT = T.let(T.unsafe(nil), String)

# The text accompanying the `@abstract` tag.
#
# @see https://github.com/lsegal/yard/blob/main/templates/default/docstring/html/abstract.erb The `@abstract` tag template
#
# source://yard-sorbet//lib/yard-sorbet/handlers/abstract_dsl_handler.rb#16
YARDSorbet::Handlers::AbstractDSLHandler::TAG_TEXT = T.let(T.unsafe(nil), String)

# Handle `enums` calls, registering enum values as constants
#
# source://yard-sorbet//lib/yard-sorbet/handlers/enums_handler.rb#7
class YARDSorbet::Handlers::EnumsHandler < ::YARD::Handlers::Ruby::Base
  # source://yard-sorbet//lib/yard-sorbet/handlers/enums_handler.rb#14
  sig { void }
  def process; end

  private

  # source://yard-sorbet//lib/yard-sorbet/handlers/enums_handler.rb#29
  sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(T::Boolean) }
  def const_assign_node?(node); end
end

# Extends any modules included via `mixes_in_class_methods`
#
# @see https://sorbet.org/docs/abstract#interfaces-and-the-included-hook Sorbet `mixes_in_class_methods` documentation
#
# source://yard-sorbet//lib/yard-sorbet/handlers/include_handler.rb#9
class YARDSorbet::Handlers::IncludeHandler < ::YARD::Handlers::Ruby::Base
  # source://yard-sorbet//lib/yard-sorbet/handlers/include_handler.rb#16
  sig { void }
  def process; end

  private

  # source://yard-sorbet//lib/yard-sorbet/handlers/include_handler.rb#30
  sig { returns(::YARD::CodeObjects::NamespaceObject) }
  def included_in; end
end

# Tracks modules that invoke `mixes_in_class_methods` for use in {IncludeHandler}
#
# @see https://sorbet.org/docs/abstract#interfaces-and-the-included-hook Sorbet `mixes_in_class_methods` documentation
#
# source://yard-sorbet//lib/yard-sorbet/handlers/mixes_in_class_methods_handler.rb#9
class YARDSorbet::Handlers::MixesInClassMethodsHandler < ::YARD::Handlers::Ruby::Base
  # source://yard-sorbet//lib/yard-sorbet/handlers/mixes_in_class_methods_handler.rb#23
  sig { void }
  def process; end

  class << self
    # source://yard-sorbet//lib/yard-sorbet/handlers/mixes_in_class_methods_handler.rb#18
    sig { params(code_obj: ::String).returns(T.nilable(::String)) }
    def mixed_in_class_methods(code_obj); end
  end
end

# A YARD Handler for Sorbet type declarations
#
# source://yard-sorbet//lib/yard-sorbet/handlers/sig_handler.rb#7
class YARDSorbet::Handlers::SigHandler < ::YARD::Handlers::Ruby::Base
  # Swap the method definition docstring and the sig docstring.
  # Parse relevant parts of the `sig` and include them as well.
  #
  # source://yard-sorbet//lib/yard-sorbet/handlers/sig_handler.rb#20
  sig { void }
  def process; end

  private

  # source://yard-sorbet//lib/yard-sorbet/handlers/sig_handler.rb#52
  sig do
    params(
      method_node: ::YARD::Parser::Ruby::AstNode,
      node: ::YARD::Parser::Ruby::AstNode,
      docstring: ::YARD::Docstring
    ).void
  end
  def parse_params(method_node, node, docstring); end

  # source://yard-sorbet//lib/yard-sorbet/handlers/sig_handler.rb#64
  sig { params(node: ::YARD::Parser::Ruby::AstNode, docstring: ::YARD::Docstring).void }
  def parse_return(node, docstring); end

  # source://yard-sorbet//lib/yard-sorbet/handlers/sig_handler.rb#32
  sig { params(method_node: ::YARD::Parser::Ruby::AstNode, docstring: ::YARD::Docstring).void }
  def parse_sig(method_node, docstring); end
end

# These node types attached to sigs represent attr_* declarations
#
# source://yard-sorbet//lib/yard-sorbet/handlers/sig_handler.rb#14
YARDSorbet::Handlers::SigHandler::ATTR_NODE_TYPES = T.let(T.unsafe(nil), Array)

# Class-level handler that folds all `const` and `prop` declarations into the constructor documentation
# this needs to be injected as a module otherwise the default Class handler will overwrite documentation
#
# @note this module is included in `YARD::Handlers::Ruby::ClassHandler`
#
# source://yard-sorbet//lib/yard-sorbet/handlers/struct_class_handler.rb#10
module YARDSorbet::Handlers::StructClassHandler
  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_class_handler.rb#14
  sig { void }
  def process; end

  private

  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_class_handler.rb#50
  sig do
    params(
      object: ::YARD::CodeObjects::MethodObject,
      props: T::Array[::YARDSorbet::TStructProp],
      docstring: ::YARD::Docstring,
      directives: T::Array[::String]
    ).void
  end
  def decorate_t_struct_init(object, props, docstring, directives); end

  # Create a virtual `initialize` method with all the `prop`/`const` arguments
  #
  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_class_handler.rb#30
  sig { params(props: T::Array[::YARDSorbet::TStructProp], class_ns: ::YARD::CodeObjects::ClassObject).void }
  def process_t_struct_props(props, class_ns); end

  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_class_handler.rb#60
  sig { params(props: T::Array[::YARDSorbet::TStructProp]).returns(T::Array[[::String, T.nilable(::String)]]) }
  def to_object_parameters(props); end
end

# Handles all `const`/`prop` calls, creating accessor methods, and compiles them for later usage at the class level
# in creating a constructor
#
# source://yard-sorbet//lib/yard-sorbet/handlers/struct_prop_handler.rb#8
class YARDSorbet::Handlers::StructPropHandler < ::YARD::Handlers::Ruby::Base
  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_prop_handler.rb#15
  sig { void }
  def process; end

  private

  # Add the source and docstring to the method object
  #
  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_prop_handler.rb#28
  sig { params(object: ::YARD::CodeObjects::MethodObject, prop: ::YARDSorbet::TStructProp).void }
  def decorate_object(object, prop); end

  # Get the default prop value
  #
  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_prop_handler.rb#39
  sig { returns(T.nilable(::String)) }
  def default_value; end

  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_prop_handler.rb#44
  sig { params(name: ::String).returns(::YARDSorbet::TStructProp) }
  def make_prop(name); end

  # Register the field explicitly as an attribute.
  # While `const` attributes are immutable, `prop` attributes may be reassigned.
  #
  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_prop_handler.rb#57
  sig { params(object: ::YARD::CodeObjects::MethodObject, name: ::String).void }
  def register_attrs(object, name); end

  # Store the prop for use in the constructor definition
  #
  # source://yard-sorbet//lib/yard-sorbet/handlers/struct_prop_handler.rb#65
  sig { params(prop: ::YARDSorbet::TStructProp).void }
  def update_state(prop); end
end

# Helper methods for working with `YARD` AST Nodes
#
# source://yard-sorbet//lib/yard-sorbet/node_utils.rb#6
module YARDSorbet::NodeUtils
  class << self
    # Traverse AST nodes in breadth-first order
    #
    # @note This will skip over some node types.
    # @yield [YARD::Parser::Ruby::AstNode]
    #
    # source://yard-sorbet//lib/yard-sorbet/node_utils.rb#22
    sig do
      params(
        node: ::YARD::Parser::Ruby::AstNode,
        _blk: T.proc.params(n: ::YARD::Parser::Ruby::AstNode).void
      ).void
    end
    def bfs_traverse(node, &_blk); end

    # Gets the node that a sorbet `sig` can be attached do, bypassing visisbility modifiers and the like
    #
    # source://yard-sorbet//lib/yard-sorbet/node_utils.rb#34
    sig do
      params(
        node: ::YARD::Parser::Ruby::AstNode
      ).returns(T.any(::YARD::Parser::Ruby::MethodCallNode, ::YARD::Parser::Ruby::MethodDefinitionNode))
    end
    def get_method_node(node); end

    # Find and return the adjacent node (ascending)
    #
    # @raise [IndexError] if the node does not have an adjacent sibling (ascending)
    #
    # source://yard-sorbet//lib/yard-sorbet/node_utils.rb#48
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(::YARD::Parser::Ruby::AstNode) }
    def sibling_node(node); end
  end
end

# Command node types that can have type signatures
#
# source://yard-sorbet//lib/yard-sorbet/node_utils.rb#10
YARDSorbet::NodeUtils::ATTRIBUTE_METHODS = T.let(T.unsafe(nil), Array)

# Skip these method contents during BFS node traversal, they can have their own nested types via `T.Proc`
#
# source://yard-sorbet//lib/yard-sorbet/node_utils.rb#12
YARDSorbet::NodeUtils::SKIP_METHOD_CONTENTS = T.let(T.unsafe(nil), Array)

# Node types that can have type signatures
#
# source://yard-sorbet//lib/yard-sorbet/node_utils.rb#14
YARDSorbet::NodeUtils::SigableNode = T.type_alias { T.any(::YARD::Parser::Ruby::MethodCallNode, ::YARD::Parser::Ruby::MethodDefinitionNode) }

# Translate `sig` type syntax to `YARD` type syntax.
#
# source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#6
module YARDSorbet::SigToYARD
  class << self
    # @see https://yardoc.org/types.html
    #
    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#21
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(T::Array[::String]) }
    def convert(node); end

    private

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#54
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(::String) }
    def build_generic_type(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#63
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(T::Array[::String]) }
    def convert_aref(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#75
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns([::String]) }
    def convert_array(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#83
    sig { params(node: ::YARD::Parser::Ruby::MethodCallNode).returns(T::Array[::String]) }
    def convert_call(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#88
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns([::String]) }
    def convert_collection(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#95
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns([::String]) }
    def convert_hash(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#103
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(T::Array[::String]) }
    def convert_list(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#27
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(T::Array[::String]) }
    def convert_node(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#36
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns(T::Array[::String]) }
    def convert_node_type(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#108
    sig { params(node_source: ::String).returns([::String]) }
    def convert_ref(node_source); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#113
    sig { params(node: ::YARD::Parser::Ruby::MethodCallNode).returns(T::Array[::String]) }
    def convert_t_method(node); end

    # source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#125
    sig { params(node: ::YARD::Parser::Ruby::AstNode).returns([::String]) }
    def convert_unknown(node); end
  end
end

# source://yard-sorbet//lib/yard-sorbet/sig_to_yard.rb#9
YARDSorbet::SigToYARD::REF_TYPES = T.let(T.unsafe(nil), Hash)

# Used to store the details of a `T::Struct` `prop` definition
#
# source://yard-sorbet//lib/yard-sorbet/t_struct_prop.rb#6
class YARDSorbet::TStructProp < ::T::Struct
  const :default, T.nilable(::String)
  const :doc, ::String
  const :prop_name, ::String
  const :source, ::String
  const :types, T::Array[::String]

  class << self
    # source://sorbet-runtime/0.5.10588/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Helper methods for working with `YARD` tags
#
# source://yard-sorbet//lib/yard-sorbet/tag_utils.rb#6
module YARDSorbet::TagUtils
  class << self
    # source://yard-sorbet//lib/yard-sorbet/tag_utils.rb#13
    sig do
      params(
        docstring: ::YARD::Docstring,
        tag_name: ::String,
        name: T.nilable(::String)
      ).returns(T.nilable(::YARD::Tags::Tag))
    end
    def find_tag(docstring, tag_name, name); end

    # Create or update a `YARD` tag with type information
    #
    # source://yard-sorbet//lib/yard-sorbet/tag_utils.rb#27
    sig do
      params(
        docstring: ::YARD::Docstring,
        tag_name: ::String,
        types: T.nilable(T::Array[::String]),
        name: T.nilable(::String),
        text: ::String
      ).void
    end
    def upsert_tag(docstring, tag_name, types = T.unsafe(nil), name = T.unsafe(nil), text = T.unsafe(nil)); end
  end
end

# {https://rubygems.org/gems/yard-sorbet Version history}
#
# source://yard-sorbet//lib/yard-sorbet/version.rb#7
YARDSorbet::VERSION = T.let(T.unsafe(nil), String)
